$date
  Sun Apr 10 20:17:48 2022
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module alu_tb $end
$var reg 4 ! a[3:0] $end
$var reg 4 " b[3:0] $end
$var reg 1 # s $end
$var reg 1 $ cuf $end
$var reg 1 % cof $end
$var reg 4 & o[3:0] $end
$scope module addsub $end
$var reg 4 ' a[3:0] $end
$var reg 4 ( b[3:0] $end
$var reg 1 ) s $end
$var reg 1 * cuf $end
$var reg 1 + cof $end
$var reg 4 , o[3:0] $end
$var reg 4 - tcomp[3:0] $end
$var reg 4 . alub[3:0] $end
$var reg 4 / facout[3:0] $end
$var reg 3 0 tcc[2:0] $end
$scope module mux $end
$var reg 4 1 a[3:0] $end
$var reg 4 2 b[3:0] $end
$var reg 1 3 s $end
$var reg 4 4 y[3:0] $end
$upscope $end
$scope module fa0 $end
$var reg 1 5 a $end
$var reg 1 6 b $end
$var reg 1 7 cin $end
$var reg 1 8 o $end
$var reg 1 9 cout $end
$upscope $end
$scope module fa1 $end
$var reg 1 : a $end
$var reg 1 ; b $end
$var reg 1 < cin $end
$var reg 1 = o $end
$var reg 1 > cout $end
$upscope $end
$scope module fa2 $end
$var reg 1 ? a $end
$var reg 1 @ b $end
$var reg 1 A cin $end
$var reg 1 B o $end
$var reg 1 C cout $end
$upscope $end
$scope module fa3 $end
$var reg 1 D a $end
$var reg 1 E b $end
$var reg 1 F cin $end
$var reg 1 G o $end
$var reg 1 H cout $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
b0100 !
b0010 "
0#
0$
0%
b0110 &
b0100 '
b0010 (
0)
0*
0+
b0110 ,
b1110 -
b0010 .
b0000 /
b001 0
b0010 1
b1110 2
03
b0010 4
05
06
07
08
09
0:
1;
0<
1=
0>
1?
0@
0A
1B
0C
0D
0E
0F
0G
0H
#1000000
b0001 "
1#
0$
b0011 &
b0001 (
1)
0*
b0011 ,
b1111 -
b1111 .
b1100 /
b000 0
b0001 1
b1111 2
13
b1111 4
16
18
1;
1=
1@
0B
1C
1E
1F
0G
1H
#2000000
b1100 !
b1001 "
1$
b0011 &
b1100 '
b1001 (
1*
b0011 ,
b0111 -
b0111 .
b1001 1
b0111 2
b0111 4
1D
0E
0G
#3000000
b0100 !
b0101 "
0#
0$
1%
b1001 &
b0100 '
b0101 (
0)
0*
1+
b1001 ,
b1011 -
b0101 .
b0100 /
b0101 1
b1011 2
03
b0101 4
0;
0=
0D
1G
0H
#4000000
